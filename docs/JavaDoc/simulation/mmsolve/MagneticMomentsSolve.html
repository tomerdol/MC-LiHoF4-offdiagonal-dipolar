<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (16) on Tue Jul 13 14:10:33 IDT 2021 -->
<title>MagneticMomentsSolve</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-07-13">
<meta name="description" content="declaration: package: simulation.mmsolve, class: MagneticMomentsSolve">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">simulation.mmsolve</a></div>
<h1 title="Class MagneticMomentsSolve" class="title">Class MagneticMomentsSolve</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">simulation.mmsolve.MagneticMomentsSolve</div>
</div>
<section class="description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">MagneticMomentsSolve</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Class of special iterative solvers used for the self-consistent determination of magnetic moments in the system.
 Three methods are implemented: Newton's and Broyden's methods and (nonlinear) Gauss-Seidel method.
 Implementations are from Numerical Recipes (3rd edition)</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><span class="member-name-link"><a href="#%3Cinit%3E()">MagneticMomentsSolve</a></span>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button><button id="method-summary-table-tab6" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab6', 3)" class="table-tab">Deprecated Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#broyden(simulation.mmsolve.fi_xi,double%5B%5D,double)">broyden</a></span>&#8203;(<a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;vecFunc,
 double[]&nbsp;x,
 double&nbsp;tol)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Runs the Broyden method.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#broyden(simulation.mmsolve.fi_xi,double%5B%5D,double,boolean,boolean)">broyden</a></span>&#8203;(<a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;vecFunc,
 double[]&nbsp;x,
 double&nbsp;tol,
 boolean&nbsp;initialJacobianIdentity,
 boolean&nbsp;changeJacobianIdentity)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Given an initial guess x[0..n-1] for a root in n dimensions, find the root by Broydenג€™s
 method embedded in a globally convergent strategy.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#checkConverge(double%5B%5D,simulation.mmsolve.fi_xi)">checkConverge</a></span>&#8203;(double[]&nbsp;x,
 <a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;f)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Checks convergence according to the absolute criterion, not just diminishing of successive changes
 which could also signify a local minimum.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#doub_vec(int)">doub_vec</a></span>&#8203;(int&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Creates a vector of doubles.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab6 method-summary-table-tab4 method-summary-table"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab6 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#gauss_seidel(simulation.mmsolve.fi_xi,double%5B%5D,double,int,double)">gauss_seidel</a></span>&#8203;(<a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;f,
 double[]&nbsp;xx,
 double&nbsp;alpha,
 int&nbsp;iter,
 double&nbsp;tol)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab6 method-summary-table-tab4 method-summary-table">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">since this is basically what the implementation of <code>MagneticMomentsSolveIter</code> in <a href="../montecarlo/Lattice.html" title="class in simulation.montecarlo"><code>Lattice</code></a> does.</div>
</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#lnsrch(double%5B%5D,double,double%5B%5D,double%5B%5D,double%5B%5D,double,double,simulation.mmsolve.f_xi)">lnsrch</a></span>&#8203;(double[]&nbsp;xold,
 double&nbsp;fold,
 double[]&nbsp;g,
 double[]&nbsp;p,
 double[]&nbsp;x,
 double&nbsp;stpmax,
 double&nbsp;EPSILON,
 <a href="f_xi.html" title="class in simulation.mmsolve">f_xi</a>&nbsp;func)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Given an n-dimensional point xold[0..n-1], the value of the function
 and gradient there, fold and g[0..n-1], and a direction p[0..n-1],
 finds a new point x[0..n-1] along the direction p from xold where the
 function or functor func has decreased "sufficiently." The new
 function value is returned.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#newt(simulation.mmsolve.fi_xi,double%5B%5D,double)">newt</a></span>&#8203;(<a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;vecfunc,
 double[]&nbsp;x,
 double&nbsp;tol)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Given an initial guess x[0..n-1] for a root in n dimensions, find the
 root by a globally convergent Newtonג€™s method.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>(package private) static void</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#printMean(double%5B%5D)">printMean</a></span>&#8203;(double[]&nbsp;arr)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">&nbsp;</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>MagneticMomentsSolve</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">MagneticMomentsSolve</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="printMean(double[])">
<h3>printMean</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">printMean</span>&#8203;<span class="parameters">(double[]&nbsp;arr)</span></div>
</section>
</li>
<li>
<section class="detail" id="gauss_seidel(simulation.mmsolve.fi_xi,double[],double,int,double)">
<h3>gauss_seidel</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">gauss_seidel</span>&#8203;<span class="parameters">(<a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;f,
 double[]&nbsp;xx,
 double&nbsp;alpha,
 int&nbsp;iter,
 double&nbsp;tol)</span>
                             throws <span class="exceptions"><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">since this is basically what the implementation of <code>MagneticMomentsSolveIter</code> in <a href="../montecarlo/Lattice.html" title="class in simulation.montecarlo"><code>Lattice</code></a> does.</div>
</div>
<div class="block">Finds roots of a function f using a nonlinear Gauss-Seidel method (with a relaxation parameter).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>f</code> - - the function whose roots are to be found</dd>
<dd><code>xx</code> - - the initial solution and also where the solution will be stored</dd>
<dd><code>alpha</code> - - relaxation parameter, the update iteration is x(new_iter)=(1-alpha)*x(previous_iter)+alpha*f[x];</dd>
<dd><code>iter</code> - - number of allowed iterations</dd>
<dd><code>tol</code> - - tolerance. how small successive changes need to get for convergence to be announced.</dd>
<dt>Returns:</dt>
<dd>the solution vector (root of f)</dd>
<dt>Throws:</dt>
<dd><code><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="checkConverge(double[],simulation.mmsolve.fi_xi)">
<h3>checkConverge</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">checkConverge</span>&#8203;<span class="parameters">(double[]&nbsp;x,
 <a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;f)</span>
                            throws <span class="exceptions"><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></span></div>
<div class="block">Checks convergence according to the absolute criterion, not just diminishing of successive changes
 which could also signify a local minimum.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - - solution vector</dd>
<dd><code>f</code> - - the function which we want to test whether x is a root of.</dd>
<dt>Returns:</dt>
<dd>the distance from absolute convergence.</dd>
<dt>Throws:</dt>
<dd><code><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="doub_vec(int)">
<h3>doub_vec</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">doub_vec</span>&#8203;<span class="parameters">(int&nbsp;n)</span></div>
<div class="block">Creates a vector of doubles.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>n</code> - - length of the vector</dd>
<dt>Returns:</dt>
<dd>a vector of zeros with length n</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="broyden(simulation.mmsolve.fi_xi,double[],double)">
<h3>broyden</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">broyden</span>&#8203;<span class="parameters">(<a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;vecFunc,
 double[]&nbsp;x,
 double&nbsp;tol)</span>
                        throws <span class="exceptions"><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></span></div>
<div class="block">Runs the Broyden method. Calculate the Jacobian matrix at the start and do not try
 to use the identity matrix, even on a second run.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></code></dd>
<dt>See Also:</dt>
<dd><a href="#broyden(simulation.mmsolve.fi_xi,double%5B%5D,double,boolean,boolean)"><code>broyden(fi_xi, double[], double, boolean, boolean)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="broyden(simulation.mmsolve.fi_xi,double[],double,boolean,boolean)">
<h3>broyden</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">broyden</span>&#8203;<span class="parameters">(<a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;vecFunc,
 double[]&nbsp;x,
 double&nbsp;tol,
 boolean&nbsp;initialJacobianIdentity,
 boolean&nbsp;changeJacobianIdentity)</span>
                        throws <span class="exceptions"><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></span></div>
<div class="block">Given an initial guess x[0..n-1] for a root in n dimensions, find the root by Broydenג€™s
 method embedded in a globally convergent strategy. The vector of functions to be zeroed
 called fvec[0..n-1] in the routine below, is returned by the user-supplied function or functor
 vecfunc. On a successful run the x[0..n-1] which zeros fvec is returned.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>vecFunc</code> - - function from R^n to R^n whose roots are to be found</dd>
<dd><code>x</code> - - initial guess</dd>
<dd><code>tol</code> - - tolerance for convergence testing</dd>
<dd><code>initialJacobianIdentity</code> - - whether to start with an identity matrix as the Jacobian</dd>
<dd><code>changeJacobianIdentity</code> - - whether to change <code>initialJacobianIdentity</code> when reinitializing
                               the Jacobian if stuck.</dd>
<dt>Returns:</dt>
<dd>the vector x[0..n-1] which is a root of the function f</dd>
<dt>Throws:</dt>
<dd><code><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></code> - if the routine has converged to a local minimum of the function
 fmin or if Broydenג€™s method can make no further progress. In this case try restarting from a
 different initial guess.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="newt(simulation.mmsolve.fi_xi,double[],double)">
<h3>newt</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">newt</span>&#8203;<span class="parameters">(<a href="fi_xi.html" title="class in simulation.mmsolve">fi_xi</a>&nbsp;vecfunc,
 double[]&nbsp;x,
 double&nbsp;tol)</span>
                     throws <span class="exceptions"><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></span></div>
<div class="block">Given an initial guess x[0..n-1] for a root in n dimensions, find the
 root by a globally convergent Newtonג€™s method. The vector of functions
 to be zeroed, called fvec[0..n-1] in the routine below, is returned
 by the user-supplied function or functor vecfunc (see text). The
 output quantity check is false on a normal return and true if the
 routine has converged to a local minimum of the function fmin defined
 below. In this case try restarting from a different initial guess.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>vecfunc</code> - - function from R^n to R^n whose roots are to be found</dd>
<dd><code>x</code> - - initial guess</dd>
<dd><code>tol</code> - - tolerance for convergence testing</dd>
<dt>Returns:</dt>
<dd>the vector x[0..n-1] which is a root of the function f</dd>
<dt>Throws:</dt>
<dd><code><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lnsrch(double[],double,double[],double[],double[],double,double,simulation.mmsolve.f_xi)">
<h3>lnsrch</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a></span>&nbsp;<span class="element-name">lnsrch</span>&#8203;<span class="parameters">(double[]&nbsp;xold,
 double&nbsp;fold,
 double[]&nbsp;g,
 double[]&nbsp;p,
 double[]&nbsp;x,
 double&nbsp;stpmax,
 double&nbsp;EPSILON,
 <a href="f_xi.html" title="class in simulation.mmsolve">f_xi</a>&nbsp;func)</span>
                     throws <span class="exceptions"><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></span></div>
<div class="block">Given an n-dimensional point xold[0..n-1], the value of the function
 and gradient there, fold and g[0..n-1], and a direction p[0..n-1],
 finds a new point x[0..n-1] along the direction p from xold where the
 function or functor func has decreased "sufficiently." The new
 function value is returned. stpmax is an input quantity that limits the
 length of the steps so that you do not try to evaluate the function
 in regions where it is undefined or subject to overflow. p is usually
 the Newton direction.
 If a proper step was taken then the value of f at the new x[0..n-1] is
 returned. The other option is that the expected step is smaller than EPSILON,
 and then we return null. In this case the calling function should check for
 convergence (delta_x convergence).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xold</code> - - starting point from which we wish to move to optimally decrease fmin</dd>
<dd><code>fold</code> - - the value of fmin at the point <code>xold</code></dd>
<dd><code>g</code> - - the gradient of f at the point <code>xold</code></dd>
<dd><code>p</code> - - vector which signifies the direction along which the step is to be taken</dd>
<dd><code>x</code> - - vector which stores the optimal point along the direction <code>p</code></dd>
<dd><code>stpmax</code> - - limit the potential length of the step</dd>
<dd><code>EPSILON</code> - - smaller possible step length</dd>
<dd><code>func</code> - - the (scalar) function to be optimally minimized by the step</dd>
<dt>Returns:</dt>
<dd>the point x[0..n-1] of maximal decrease of the function <code>func</code>, or null
          if the proposed step is smaller than <code>EPSILON</code></dd>
<dt>Throws:</dt>
<dd><code><a href="ConvergenceException.html" title="class in simulation.mmsolve">ConvergenceException</a></code></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
